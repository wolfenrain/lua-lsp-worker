<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Lua Language Server Playground</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}
			html,
			body {
				height: 100%;
				overflow: hidden;
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
				background: #1e1e1e;
				color: #d4d4d4;
			}
			.container {
				display: flex;
				flex-direction: column;
				height: 100%;
			}
			header {
				padding: 12px 20px;
				background: #252526;
				border-bottom: 1px solid #3c3c3c;
				display: flex;
				align-items: center;
				justify-content: space-between;
			}
			header h1 {
				font-size: 16px;
				font-weight: 500;
				display: flex;
				align-items: center;
				gap: 8px;
			}
			header h1 .lua-icon {
				width: 20px;
				height: 20px;
			}
			.status {
				display: flex;
				align-items: center;
				gap: 8px;
				font-size: 13px;
			}
			.status-indicator {
				width: 8px;
				height: 8px;
				border-radius: 50%;
				background: #f59e0b;
			}
			.status-indicator.connected {
				background: #22c55e;
			}
			.status-indicator.disconnected {
				background: #ef4444;
			}
			.status-indicator.idle {
				background: #6b7280;
			}
			#editor-container {
				flex: 1;
				overflow: hidden;
			}
			footer {
				padding: 8px 20px;
				background: #007acc;
				font-size: 12px;
				display: flex;
				justify-content: space-between;
			}
			footer a {
				color: white;
				text-decoration: none;
				display: inline-flex;
				align-items: center;
				gap: 4px;
			}
			footer a:hover {
				text-decoration: underline;
			}
			footer svg {
				width: 14px;
				height: 14px;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<header>
				<h1>Lua Language Server Playground</h1>
				<div class="status">
					<span class="status-indicator" id="status-indicator"></span>
					<span id="status-text">Connecting...</span>
				</div>
			</header>
			<div id="editor-container"></div>
			<footer>
				<span>Powered by <a href="https://github.com/LuaLS/lua-language-server" target="_blank">LuaLS</a></span>
				<a href="https://github.com/wolfenrain/lua-lsp-worker" target="_blank">
					<svg viewBox="0 0 16 16" fill="currentColor">
						<path
							d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
						/>
					</svg>
					GitHub
				</a>
			</footer>
		</div>

		<script type="importmap">
			{
				"imports": {
					"monaco-editor": "https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/+esm",
					"vscode": "https://cdn.jsdelivr.net/npm/@codingame/monaco-vscode-api@12.0.0/+esm",
					"vscode-languageclient": "https://cdn.jsdelivr.net/npm/vscode-languageclient@9.0.1/+esm",
					"vscode-jsonrpc": "https://cdn.jsdelivr.net/npm/vscode-jsonrpc@8.2.1/+esm",
					"vscode-languageserver-protocol": "https://cdn.jsdelivr.net/npm/vscode-languageserver-protocol@3.17.5/+esm"
				}
			}
		</script>

		<script type="module">
			// Load Monaco Editor
			const monaco = await import('https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/+esm');

			// Register Lua language
			monaco.languages.register({ id: 'lua' });

			// Sample Lua code
			const sampleCode = `-- Lua Language Server Playground
-- Try editing this code to see LSP features in action!

---@class Player
---@field name string The player's name
---@field health number Current health points
---@field inventory table<string, number> Items and quantities
local Player = {}
Player.__index = Player

---Creates a new player
---@param name string The player's name
---@return Player
function Player.new(name)
    local self = setmetatable({}, Player)
    self.name = name
    self.health = 100
    self.inventory = {}
    return self
end

---Adds an item to the player's inventory
---@param item string The item name
---@param quantity? number The quantity to add (default: 1)
function Player:addItem(item, quantity)
    quantity = quantity or 1
    self.inventory[item] = (self.inventory[item] or 0) + quantity
    print(string.format("%s picked up %d x %s", self.name, quantity, item))
end

---Checks if the player has an item
---@param item string The item to check
---@return boolean hasItem Whether the player has the item
---@return number count The quantity of the item
function Player:hasItem(item)
    local count = self.inventory[item] or 0
    return count > 0, count
end

-- Create a player and test the API
local player = Player.new("Hero")
player:addItem("sword")
player:addItem("potion", 5)

local hasSword, swordCount = player:hasItem("sword")
if hasSword then
    print(player.name .. " is armed!")
end

-- Try hovering over functions and variables
-- Try triggering autocomplete with Ctrl+Space
-- The LSP provides diagnostics, completions, and more!
`;

			// Create the editor
			const editor = monaco.editor.create(document.getElementById('editor-container'), {
				value: sampleCode,
				language: 'lua',
				theme: 'vs-dark',
				fontSize: 14,
				lineNumbers: 'on',
				minimap: { enabled: true },
				scrollBeyondLastLine: false,
				automaticLayout: true,
				tabSize: 2,
				wordWrap: 'on',
				suggest: {
					showKeywords: true,
					showSnippets: true,
				},
			});

			// LSP Connection
			const statusIndicator = document.getElementById('status-indicator');
			const statusText = document.getElementById('status-text');

			function updateStatus(status, text) {
				statusIndicator.className = 'status-indicator ' + status;
				statusText.textContent = text;
			}

			// WebSocket LSP Client
			const IDLE_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes

			class LspClient {
				constructor() {
					this.ws = null;
					this.requestId = 0;
					this.pendingRequests = new Map();
					this.documentVersion = 0;
					this.documentUri = 'file:///workspace/playground.lua';
					this.diagnosticsMarkers = [];
					this.idleTimer = null;
					this.isIdle = false;
					this.lastContent = null;
				}

				connect() {
					if (this.ws && this.ws.readyState === WebSocket.OPEN) return;

					const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
					const wsUrl = `${protocol}//${window.location.host}`;

					updateStatus('', 'Connecting...');
					this.isIdle = false;
					this.ws = new WebSocket(wsUrl);

					this.ws.onopen = () => {
						updateStatus('connected', 'Connected');
						this.resetIdleTimer();
						this.initialize();
					};

					this.ws.onmessage = (event) => {
						try {
							const message = JSON.parse(event.data);
							this.handleMessage(message);
						} catch (e) {
							console.error('Failed to parse message:', e);
						}
					};

					this.ws.onclose = () => {
						if (this.isIdle) {
							updateStatus('idle', 'Idle - interact to reconnect');
						} else {
							updateStatus('disconnected', 'Disconnected');
							// Try to reconnect after 3 seconds (unexpected disconnect)
							setTimeout(() => this.connect(), 3000);
						}
					};

					this.ws.onerror = (error) => {
						console.error('WebSocket error:', error);
						updateStatus('disconnected', 'Connection error');
					};
				}

				disconnect() {
					this.clearIdleTimer();
					this.isIdle = true;
					this.lastContent = editor.getValue();
					if (this.ws) {
						this.ws.close();
						this.ws = null;
					}
				}

				resetIdleTimer() {
					this.clearIdleTimer();
					this.idleTimer = setTimeout(() => {
						console.log('Idle timeout reached, disconnecting...');
						this.disconnect();
					}, IDLE_TIMEOUT_MS);
				}

				clearIdleTimer() {
					if (this.idleTimer) {
						clearTimeout(this.idleTimer);
						this.idleTimer = null;
					}
				}

				onActivity() {
					if (this.isIdle) {
						// Reconnect on activity
						this.connect();
					} else {
						this.resetIdleTimer();
					}
				}

				sendRequest(method, params) {
					return new Promise((resolve, reject) => {
						const id = ++this.requestId;
						const message = {
							jsonrpc: '2.0',
							id,
							method,
							params,
						};

						this.pendingRequests.set(id, { resolve, reject, method });
						this.ws.send(JSON.stringify(message));
					});
				}

				sendNotification(method, params) {
					const message = {
						jsonrpc: '2.0',
						method,
						params,
					};
					this.ws.send(JSON.stringify(message));
				}

				handleMessage(message) {
					// Handle response to request
					if (message.id !== undefined && this.pendingRequests.has(message.id)) {
						const { resolve, reject, method } = this.pendingRequests.get(message.id);
						this.pendingRequests.delete(message.id);

						if (message.error) {
							reject(message.error);
						} else {
							resolve(message.result);
						}
						return;
					}

					// Handle notifications from server
					if (message.method) {
						this.handleNotification(message.method, message.params);
					}
				}

				handleNotification(method, params) {
					switch (method) {
						case 'textDocument/publishDiagnostics':
							this.handleDiagnostics(params);
							break;
						case 'window/logMessage':
						case 'window/showMessage':
							console.log('[LSP]', params.message);
							break;
					}
				}

				handleDiagnostics(params) {
					if (params.uri !== this.documentUri) return;

					// Clear old markers
					monaco.editor.setModelMarkers(editor.getModel(), 'lua-lsp', []);

					// Convert diagnostics to Monaco markers
					const markers = params.diagnostics.map((d) => ({
						severity: this.toMonacoSeverity(d.severity),
						startLineNumber: d.range.start.line + 1,
						startColumn: d.range.start.character + 1,
						endLineNumber: d.range.end.line + 1,
						endColumn: d.range.end.character + 1,
						message: d.message,
						source: d.source || 'lua-language-server',
					}));

					monaco.editor.setModelMarkers(editor.getModel(), 'lua-lsp', markers);
				}

				toMonacoSeverity(severity) {
					switch (severity) {
						case 1:
							return monaco.MarkerSeverity.Error;
						case 2:
							return monaco.MarkerSeverity.Warning;
						case 3:
							return monaco.MarkerSeverity.Info;
						case 4:
							return monaco.MarkerSeverity.Hint;
						default:
							return monaco.MarkerSeverity.Info;
					}
				}

				async initialize() {
					try {
						const result = await this.sendRequest('initialize', {
							processId: null,
							clientInfo: {
								name: 'Lua LSP Web Client',
								version: '1.0.0',
							},
							rootUri: 'file:///workspace',
							capabilities: {
								textDocument: {
									synchronization: {
										dynamicRegistration: false,
										willSave: false,
										willSaveWaitUntil: false,
										didSave: true,
									},
									completion: {
										dynamicRegistration: false,
										completionItem: {
											snippetSupport: true,
											documentationFormat: ['markdown', 'plaintext'],
											deprecatedSupport: true,
											preselectSupport: true,
										},
										contextSupport: true,
									},
									hover: {
										dynamicRegistration: false,
										contentFormat: ['markdown', 'plaintext'],
									},
									signatureHelp: {
										dynamicRegistration: false,
										signatureInformation: {
											documentationFormat: ['markdown', 'plaintext'],
											parameterInformation: {
												labelOffsetSupport: true,
											},
										},
									},
									definition: { dynamicRegistration: false },
									references: { dynamicRegistration: false },
									documentHighlight: { dynamicRegistration: false },
									documentSymbol: { dynamicRegistration: false },
									formatting: { dynamicRegistration: false },
									publishDiagnostics: {
										relatedInformation: true,
									},
								},
								workspace: {
									workspaceFolders: true,
								},
							},
							workspaceFolders: [{ uri: 'file:///workspace', name: 'workspace' }],
						});

						console.log('LSP initialized:', result);

						// Send initialized notification
						this.sendNotification('initialized', {});

						// Open the document with current editor content
						this.openDocument(editor.getValue());

						// Register completion provider
						this.registerCompletionProvider();

						// Register hover provider
						this.registerHoverProvider();

						// Register signature help provider
						this.registerSignatureHelpProvider();
					} catch (error) {
						console.error('Failed to initialize LSP:', error);
						updateStatus('disconnected', 'Initialization failed');
					}
				}

				openDocument(text) {
					this.sendNotification('textDocument/didOpen', {
						textDocument: {
							uri: this.documentUri,
							languageId: 'lua',
							version: this.documentVersion,
							text,
						},
					});
				}

				registerCompletionProvider() {
					monaco.languages.registerCompletionItemProvider('lua', {
						triggerCharacters: ['.', ':', '"', "'", '/', '@'],
						provideCompletionItems: async (model, position) => {
							try {
								const result = await this.sendRequest('textDocument/completion', {
									textDocument: { uri: this.documentUri },
									position: {
										line: position.lineNumber - 1,
										character: position.column - 1,
									},
								});

								if (!result) return { suggestions: [] };

								const items = Array.isArray(result) ? result : result.items || [];

								return {
									suggestions: items.map((item) => ({
										label: item.label,
										kind: this.toMonacoCompletionKind(item.kind),
										insertText: item.insertText || item.label,
										insertTextRules:
											item.insertTextFormat === 2 ? monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet : undefined,
										detail: item.detail,
										documentation: item.documentation?.value || item.documentation,
										sortText: item.sortText,
										filterText: item.filterText,
									})),
								};
							} catch (error) {
								console.error('Completion error:', error);
								return { suggestions: [] };
							}
						},
					});
				}

				toMonacoCompletionKind(kind) {
					const kindMap = {
						1: monaco.languages.CompletionItemKind.Text,
						2: monaco.languages.CompletionItemKind.Method,
						3: monaco.languages.CompletionItemKind.Function,
						4: monaco.languages.CompletionItemKind.Constructor,
						5: monaco.languages.CompletionItemKind.Field,
						6: monaco.languages.CompletionItemKind.Variable,
						7: monaco.languages.CompletionItemKind.Class,
						8: monaco.languages.CompletionItemKind.Interface,
						9: monaco.languages.CompletionItemKind.Module,
						10: monaco.languages.CompletionItemKind.Property,
						11: monaco.languages.CompletionItemKind.Unit,
						12: monaco.languages.CompletionItemKind.Value,
						13: monaco.languages.CompletionItemKind.Enum,
						14: monaco.languages.CompletionItemKind.Keyword,
						15: monaco.languages.CompletionItemKind.Snippet,
						16: monaco.languages.CompletionItemKind.Color,
						17: monaco.languages.CompletionItemKind.File,
						18: monaco.languages.CompletionItemKind.Reference,
						19: monaco.languages.CompletionItemKind.Folder,
						20: monaco.languages.CompletionItemKind.EnumMember,
						21: monaco.languages.CompletionItemKind.Constant,
						22: monaco.languages.CompletionItemKind.Struct,
						23: monaco.languages.CompletionItemKind.Event,
						24: monaco.languages.CompletionItemKind.Operator,
						25: monaco.languages.CompletionItemKind.TypeParameter,
					};
					return kindMap[kind] || monaco.languages.CompletionItemKind.Text;
				}

				registerHoverProvider() {
					monaco.languages.registerHoverProvider('lua', {
						provideHover: async (model, position) => {
							try {
								const result = await this.sendRequest('textDocument/hover', {
									textDocument: { uri: this.documentUri },
									position: {
										line: position.lineNumber - 1,
										character: position.column - 1,
									},
								});

								if (!result || !result.contents) return null;

								let contents;
								if (typeof result.contents === 'string') {
									contents = [{ value: result.contents }];
								} else if (result.contents.value) {
									contents = [{ value: result.contents.value }];
								} else if (Array.isArray(result.contents)) {
									contents = result.contents.map((c) => (typeof c === 'string' ? { value: c } : { value: c.value || String(c) }));
								} else {
									contents = [{ value: String(result.contents) }];
								}

								return {
									contents,
									range: result.range
										? {
												startLineNumber: result.range.start.line + 1,
												startColumn: result.range.start.character + 1,
												endLineNumber: result.range.end.line + 1,
												endColumn: result.range.end.character + 1,
											}
										: undefined,
								};
							} catch (error) {
								console.error('Hover error:', error);
								return null;
							}
						},
					});
				}

				registerSignatureHelpProvider() {
					monaco.languages.registerSignatureHelpProvider('lua', {
						signatureHelpTriggerCharacters: ['(', ','],
						provideSignatureHelp: async (model, position) => {
							try {
								const result = await this.sendRequest('textDocument/signatureHelp', {
									textDocument: { uri: this.documentUri },
									position: {
										line: position.lineNumber - 1,
										character: position.column - 1,
									},
								});

								if (!result || !result.signatures || result.signatures.length === 0) {
									return null;
								}

								return {
									value: {
										signatures: result.signatures.map((sig) => ({
											label: sig.label,
											documentation: sig.documentation?.value || sig.documentation,
											parameters: (sig.parameters || []).map((p) => ({
												label: p.label,
												documentation: p.documentation?.value || p.documentation,
											})),
										})),
										activeSignature: result.activeSignature || 0,
										activeParameter: result.activeParameter || 0,
									},
									dispose: () => {},
								};
							} catch (error) {
								console.error('Signature help error:', error);
								return null;
							}
						},
					});
				}
			}

			// Start the LSP client
			const lspClient = new LspClient();
			lspClient.connect();

			// Set up activity tracking
			editor.onDidChangeModelContent(() => {
				lspClient.onActivity();
				if (lspClient.ws && lspClient.ws.readyState === WebSocket.OPEN) {
					lspClient.documentVersion++;
					lspClient.sendNotification('textDocument/didChange', {
						textDocument: {
							uri: lspClient.documentUri,
							version: lspClient.documentVersion,
						},
						contentChanges: [{ text: editor.getValue() }],
					});
				}
			});

			// Track other activity events
			editor.onDidFocusEditorWidget(() => lspClient.onActivity());
			editor.onDidChangeCursorPosition(() => lspClient.onActivity());
			document.getElementById('editor-container').addEventListener('click', () => lspClient.onActivity());

			// Handle page visibility - disconnect when tab is hidden
			document.addEventListener('visibilitychange', () => {
				if (document.hidden) {
					lspClient.disconnect();
				}
			});
		</script>
	</body>
</html>
